{
    "language": "Solidity",
    "sources": {
        "contracts/flat/SushiSwapSwapperFlat.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n// Version 11-Mar-2021\n\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.1.0\n// License-Identifier: MIT\n\n/// @notice A library for performing overflow-/underflow-safe math,\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\nlibrary BoringMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\n    }\n}\n\n// File @sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol@v1.4.2\n// License-Identifier: GPL-3.0\ninterface IUniswapV2Factory {\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n\n// File @sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol@v1.4.2\n// License-Identifier: GPL-3.0\ninterface IUniswapV2Pair {\n    function token0() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n}\n\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.1.0\n// License-Identifier: MIT\ninterface IERC20 {\n\n}\n\n// File @sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol@v1.0.0\n// License-Identifier: MIT\ninterface IBentoBoxV1 {\n    function deposit(\n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    function toAmount(\n        IERC20 token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    function toShare(\n        IERC20 token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    function transfer(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    function withdraw(\n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n}\n\n// File contracts/swappers/SushiSwapSwapper.sol\n// License-Identifier: MIT\ncontract SushiSwapSwapperV1 {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public immutable bentoBox;\n    IUniswapV2Factory public immutable factory;\n    bytes32 public pairCodeHash;\n\n    constructor(\n        IBentoBoxV1 bentoBox_,\n        IUniswapV2Factory factory_,\n        bytes32 pairCodeHash_\n    ) public {\n        bentoBox = bentoBox_;\n        factory = factory_;\n        pairCodeHash = pairCodeHash_;\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @notice Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\n    /// Swaps it for at least 'amountToMin' of token 'to'.\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\n    /// Returns the amount of tokens 'to' transferred to BentoBox.\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n        (IERC20 token0, IERC20 token1) = fromToken < toToken ? (fromToken, toToken) : (toToken, fromToken);\n        IUniswapV2Pair pair =\n            IUniswapV2Pair(\n                uint256(\n                    keccak256(abi.encodePacked(hex\"ff\", factory, keccak256(abi.encodePacked(address(token0), address(token1))), pairCodeHash))\n                )\n            );\n\n        (uint256 amountFrom, ) = bentoBox.withdraw(fromToken, address(this), address(pair), 0, shareFrom);\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        uint256 amountTo;\n        if (toToken > fromToken) {\n            amountTo = getAmountOut(amountFrom, reserve0, reserve1);\n            pair.swap(0, amountTo, address(bentoBox), new bytes(0));\n        } else {\n            amountTo = getAmountOut(amountFrom, reserve1, reserve0);\n            pair.swap(amountTo, 0, address(bentoBox), new bytes(0));\n        }\n        (, shareReturned) = bentoBox.deposit(toToken, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @notice Calculates the amount of token 'from' needed to complete the swap (amountFrom),\n    /// this should be less than or equal to amountFromMax.\n    /// Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\n    /// Swaps it for exactly 'exactAmountTo' of token 'to'.\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\n    /// Transfers allocated, but unused 'from' tokens within the BentoBox to 'refundTo' (amountFromMax - amountFrom).\n    /// Returns the amount of 'from' tokens withdrawn from BentoBox (amountFrom).\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public returns (uint256 shareUsed, uint256 shareReturned) {\n        IUniswapV2Pair pair;\n        {\n            (IERC20 token0, IERC20 token1) = fromToken < toToken ? (fromToken, toToken) : (toToken, fromToken);\n            pair = IUniswapV2Pair(\n                uint256(\n                    keccak256(abi.encodePacked(hex\"ff\", factory, keccak256(abi.encodePacked(address(token0), address(token1))), pairCodeHash))\n                )\n            );\n        }\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        uint256 amountToExact = bentoBox.toAmount(toToken, shareToExact, true);\n\n        uint256 amountFrom;\n        if (toToken > fromToken) {\n            amountFrom = getAmountIn(amountToExact, reserve0, reserve1);\n            (, shareUsed) = bentoBox.withdraw(fromToken, address(this), address(pair), amountFrom, 0);\n            pair.swap(0, amountToExact, address(bentoBox), \"\");\n        } else {\n            amountFrom = getAmountIn(amountToExact, reserve1, reserve0);\n            (, shareUsed) = bentoBox.withdraw(fromToken, address(this), address(pair), amountFrom, 0);\n            pair.swap(amountToExact, 0, address(bentoBox), \"\");\n        }\n        bentoBox.deposit(toToken, address(bentoBox), recipient, 0, shareToExact);\n        shareReturned = shareFromSupplied.sub(shareUsed);\n        if (shareReturned > 0) {\n            bentoBox.transfer(fromToken, address(this), refundTo, shareReturned);\n        }\n    }\n}\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 500000
        },
        "outputSelection": {
            "*": {
                "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers"],
                "": ["ast"]
            }
        }
    }
}
